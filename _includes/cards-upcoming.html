<div class="title"><h2>Upcoming Events</h2></div>
<div id="events" class="cards-row" aria-live="polite"></div>
<script>
(async function(){
  const BASEURL = "{{ site.baseurl | default: '' }}";
  const CALENDAR_URL = BASEURL + "/assets/data/calendar.json";
  const TIMEZONE = 'Asia/Kolkata';
  const fallbackImage = "https://via.placeholder.com/800x450?text=Event+Image";
  const container = document.getElementById("events");

  const EVENTS = window.__EVENTS_METADATA || (window.__EVENTS_METADATA = {% include events-metadata.json %});

  if (!container) return;

  setSkeletons(container, 3);

  function normalizeSlug(value){
    if (!value) return '';
    return value.toString()
      .normalize('NFKD')
      .replace(/[\u0300-\u036f]/g,'')
      .toLowerCase()
      .replace(/[^a-z0-9]+/g,'-')
      .replace(/^-+|-+$/g,'');
  }

  function withTransform(url){
    if (!url) return '';
    if (/\/tr:/.test(url) || /[?&]tr=/.test(url)) return url;
    if (url.includes('imagekit.io')){
      return url.replace(/(imagekit\.io\/[^/]+)/, '$1/tr:w-800,h-450,fo-auto');
    }
    return url + (url.includes('?') ? '&' : '?') + 'tr=w-800,h-450,fo-auto';
  }

  const metaBySlug = new Map();
  const metaByTitle = new Map();
  EVENTS.forEach(evt => {
    if (!evt) return;
    const slug = normalizeSlug(evt.slug || evt.title);
    if (slug) metaBySlug.set(slug, evt);
    if (evt.title) metaByTitle.set(evt.title.toLowerCase(), evt);
  });

  function formatDate(date, timezone){
    const parts = new Intl.DateTimeFormat('en-US', {
      weekday: 'short',
      day: '2-digit',
      month: 'short',
      year: '2-digit',
      timeZone: timezone
    }).formatToParts(date).reduce((acc, part) => {
      if (part.type !== 'literal') acc[part.type] = part.value;
      return acc;
    }, {});
    return `${parts.weekday || ''}, ${parts.day || ''} ${parts.month || ''} '${parts.year || ''}`.trim();
  }

  function formatTime(date, timezone){
    const str = new Intl.DateTimeFormat('en-US', {
      hour: '2-digit',
      minute: '2-digit',
      hour12: true,
      timeZone: timezone
    }).format(date).replace(/\u202f/g, ' ');
    return str.toUpperCase();
  }

  try{
    const res = await fetch(CALENDAR_URL + '?v=' + Date.now(), { cache: 'no-store' });
    if (!res.ok) throw new Error('Calendar fetch failed: ' + res.status);
    const data = await res.json();
    const timezone = (typeof data.timezone === 'string' && data.timezone.trim()) || TIMEZONE;
    const list = Array.isArray(data.events) ? data.events.slice() : [];

    list.sort((a, b) => {
      const da = a?.start ? new Date(a.start) : null;
      const db = b?.start ? new Date(b.start) : null;
      if (!da) return 1;
      if (!db) return -1;
      return da - db;
    });

    if (list.length > 0) setSkeletons(container, list.length);

    const titleNodes = new Set();
    const mobileQuery = window.matchMedia('(max-width: 768px)');
    let recomputeQueued = false;

    function clearMobileSizing(){
      const root = document.documentElement;
      root.style.removeProperty('--mobile-title-size');
      container.style.removeProperty('--mobile-title-size');
      titleNodes.forEach(title => {
        if (!title) return;
        title.style.removeProperty('--mobile-title-size');
        title.style.removeProperty('font-size');
      });
    }

    function recomputeMobileTitleSize(){
      const root = document.documentElement;
      if (!mobileQuery.matches){
        clearMobileSizing();
        return;
      }

      let targetSize = Infinity;
      const minSize = 11;
      const maxIterations = 40;

      titleNodes.forEach(title => {
        if (!title?.isConnected) return;
        title.style.removeProperty('--mobile-title-size');
        title.style.removeProperty('font-size');
      });

      titleNodes.forEach(title => {
        if (!title?.isConnected) return;

        const computedSize = parseFloat(window.getComputedStyle(title).fontSize) || 16;
        let size = computedSize;
        let iterations = 0;

        while (title.scrollWidth > title.clientWidth + 0.5 && size > minSize && iterations < maxIterations){
          size -= 0.5;
          title.style.setProperty('font-size', `${size}px`, 'important');
          // Force layout so Safari recalculates scrollWidth before the next iteration.
          void title.offsetWidth;
          iterations++;
        }

        if (title.scrollWidth > title.clientWidth + 0.5){
          size = Math.max(size, minSize);
        }

        targetSize = Math.min(targetSize, size);
        title.style.removeProperty('font-size');
      });

      if (targetSize === Infinity) return;

      const value = `${targetSize}px`;
      root.style.setProperty('--mobile-title-size', value);
      container.style.setProperty('--mobile-title-size', value);
      titleNodes.forEach(title => {
        if (!title?.isConnected) return;
        title.style.setProperty('--mobile-title-size', value);
        title.style.setProperty('font-size', value, 'important');
      });
    }

    function queueMobileTitleFit(){
      if (recomputeQueued) return;
      recomputeQueued = true;
      requestAnimationFrame(() => {
        recomputeQueued = false;
        recomputeMobileTitleSize();
      });
    }

    function registerTitle(title){
      if (!title) return;
      titleNodes.add(title);
      queueMobileTitleFit();
    }

    window.addEventListener('resize', queueMobileTitleFit);
    window.addEventListener('pageshow', queueMobileTitleFit);
    if (typeof mobileQuery.addEventListener === 'function'){
      mobileQuery.addEventListener('change', queueMobileTitleFit);
    } else if (typeof mobileQuery.addListener === 'function'){
      mobileQuery.addListener(queueMobileTitleFit);
    }

    if (document.fonts && document.fonts.ready){
      document.fonts.ready.then(() => queueMobileTitleFit());
    }

    if ('ResizeObserver' in window){
      const observer = new ResizeObserver(() => queueMobileTitleFit());
      observer.observe(container);
    }

    list.forEach((entry, idx) => {
      if (!entry) return;
      const slug = normalizeSlug(entry.slug || entry.title);
      const meta = (slug && metaBySlug.get(slug)) || (entry.title ? metaByTitle.get(entry.title.toLowerCase()) : null);
      const title = meta?.title || entry.title || 'Untitled Event';
      const card = document.createElement('article');
      card.className = 'card';

      const media = document.createElement('div');
      media.className = 'media';
      const img = document.createElement('img');
      const banner = meta?.banner ? withTransform(meta.banner) : fallbackImage;
      img.loading = 'lazy';
      img.src = banner || fallbackImage;
      img.alt = title || 'Event image';
      img.width = 800; img.height = 450;
      img.onerror = function(){ this.onerror = null; this.src = fallbackImage; };
      media.appendChild(img);
      card.appendChild(media);

      const details = document.createElement('div');
      details.className = 'card-details';

      const body = document.createElement('div');
      body.className = 'card-body';

      const h = document.createElement('h3');
      h.className = 'event-title';
      h.textContent = title;
      body.appendChild(h);

      const start = entry.start ? new Date(entry.start) : null;
      const dateLabel = start ? formatDate(start, timezone) : '';
      const timeLabel = start ? formatTime(start, timezone) : '';

      const metaLine = document.createElement('p');
      metaLine.className = 'meta';
      metaLine.textContent = [dateLabel, timeLabel].filter(Boolean).join(' | ');
      body.appendChild(metaLine);

      if (entry.location_warning && entry.raw_location){
        console.warn('Calendar location mismatch for "%s": "%s"', title, entry.raw_location);
      }

      const locationText = entry.location_name || 'To be Announced';
      if (locationText){
        const locP = document.createElement('p');
        locP.className = 'location';
        locP.textContent = locationText;
        locP.title = locationText;
        body.appendChild(locP);
      }

      if (timeLabel){
        const timeP = document.createElement('p');
        timeP.className = 'time-line';
        timeP.textContent = timeLabel;
        timeP.title = timeLabel;
        body.appendChild(timeP);
      }

      details.appendChild(body);

      if (start){
        const dayNum = new Intl.DateTimeFormat('en-US', { day: '2-digit', timeZone: timezone }).format(start);
        const monthShort = new Intl.DateTimeFormat('en-US', { month: 'short', timeZone: timezone }).format(start);
        const dateBox = document.createElement('div');
        dateBox.className = 'card-date';
        dateBox.innerHTML = `
          <div class="day">${dayNum}</div>
          <div class="month">${monthShort}</div>`;
        details.appendChild(dateBox);
      }

      card.appendChild(details);

      const footer = document.createElement('div');
      footer.className = 'card-footer';
      const fallbackLink = slug ? BASEURL + '/events/' + slug + '/' : '';
      const pageLink = meta?.url || (entry.page_url || fallbackLink);
      if (pageLink){
        const btn = document.createElement('a');
        btn.className = 'book-btn';
        btn.href = pageLink;
        btn.textContent = 'Details';
        btn.target = '_self';
        btn.removeAttribute('rel');
        footer.appendChild(btn);
      }
      card.appendChild(footer);

      card.addEventListener('click', function(e){
        if (e.target.closest('a,button')) return;
        if (window.innerWidth <= 768 && pageLink){
          window.location.href = pageLink;
        }
      });

      replaceSkeletonWithCard(container, idx, card);
      registerTitle(h);
    });

    queueMobileTitleFit();

    if (!list.length){
      container.innerHTML = '<p style="color:#bbb">No upcoming events.</p>';
    }
  } catch (err) {
    console.error('Upcoming events error:', err);
    container.innerHTML = '<p style="color:#f66">Could not load events — check the calendar artifact and CSP settings.</p>';
  }
})();
</script>
